<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script>
      function solution(board) {
        const n = board.length
        let count = 0
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (j < n - 1 && board[i][j] !== board[i][j + 1]) {
              // 바로 오른쪽에 있는 사탕과 위치를 바꾸어본다.
              let temp = board[i][j]
              board[i][j] = board[i][j + 1]
              board[i][j + 1] = temp
              // 사탕이 깨지는 경우의 수를 센다.
              if (check(board)) {
                count++
              }
              // 다시 원래대로 돌린다.
              temp = board[i][j]
              board[i][j] = board[i][j + 1]
              board[i][j + 1] = temp
            }
            if (i < n - 1 && board[i][j] !== board[i + 1][j]) {
              // 바로 아래에 있는 사탕과 위치를 바꾸어본다.
              let temp = board[i][j]
              board[i][j] = board[i + 1][j]
              board[i + 1][j] = temp
              // 사탕이 깨지는 경우의 수를 센다.
              if (check(board)) {
                count++
              }
              // 다시 원래대로 돌린다.
              temp = board[i][j]
              board[i][j] = board[i + 1][j]
              board[i + 1][j] = temp
            }
          }
        }
        return count > 0 ? count : -1
      }

      function check(board) {
        const n = board.length
        let flag = false
        // 가로로 같은 모양의 사탕이 3개 이상 연결되어 있는 경우를 찾는다.
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n - 2; j++) {
            if (board[i][j] === board[i][j + 1] && board[i][j + 1] === board[i][j + 2]) {
              flag = true
            }
          }
        }
        // 세로로 같은 모양의 사탕이 3개 이상 연결되어 있는 경우를 찾는다.
        for (let i = 0; i < n - 2; i++) {
          for (let j = 0; j < n; j++) {
            if (board[i][j] === board[i + 1][j] && board[i + 1][j] === board[i + 2][j]) {
              flag = true
            }
          }
        }
        return flag
      }

      //   var result = solution([
      //     [1, 1, 4, 3],
      //     [3, 2, 1, 4],
      //     [3, 1, 4, 2],
      //     [2, 1, 3, 3],
      //   ])
      var result = solution([
        [1, 2, 1, 2],
        [3, 4, 3, 4],
        [1, 2, 1, 2],
        [3, 4, 3, 4],
      ])
      console.log(`답은 ::::: ${result} ::::: 입니다.`)
    </script>
  </head>
  <body>
    이 게임은 같은 모양의 사탕을 깨트리는 게임입니다. 사탕은 4가지 모양이 있으며, 각각 1,2,3,4로 표시됩니다. 각각의
    사탕은 가로 또는 세로로 인접한 사탕과 위치를 바꿀 수 있습니다. 위치를 바꿨을 때, 가로 또는 세로로 같은 모양의 사탕이
    3개이상 연결되어 있으면 해당 사탕이 모두 깨집니다. 사탕을 깨트리는 방식은 다음과 같습니다. 1. 임의의 사탕을
    선택하여, 가로 혹은 세로 방향으로 인접한 사탕과 위치를 바꾸어봅니다. 단, 인접한 사탕과 위치를 바꿀 때는 게임 화면을
    넘어갈 수 없습니다. 2. 위치를 바꾼 두개의 사탕이 각각 가로 혹은 세로 방향으로 같은 모양의 사탕이 3개 이상과 연결되면
    깨집니다. 우리는 사탕의 위치를 서로 바꿨을때, 사탕을 깨트릴 수 있는 경우의 수를 구하려고 합니다. 단, 경우의 수를
    고려할 때는 두 사탕 (a,b)를 바꿀 때 a를 b와 바꾸는 경우와 b를 a와 바꾸는 경우는 같은 경우로 계산합니다. 게임화면
    board가 매개변수로 주어졌을 때, 경우의 수를 return하도록 solution함수를 javascript로 완성해주세요. 경우의 수가 없을
    때는 -1을 return해주세요. 게임화면 board는 2차원 배열로 주어지며, 1,2,3,4만 이루어져있습니다. 게임화면 board의 가로,
    세로 길이 : 3이상 10이하의 자연수이며, 가로와 세로의 길이는 같습니다. 처음에 주어진 화면에서는 가로 또는 세로로 같은
    모양의 사탕이 3개 이상 연결되어 있는 경우는 없습니다.
  </body>
</html>
